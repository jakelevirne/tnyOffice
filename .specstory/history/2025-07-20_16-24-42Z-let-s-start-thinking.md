<!-- Generated by SpecStory -->

# 2025-07-20 16:24:42Z

<!-- Claude Code Session b9be3648-01df-49d6-ad65-6831c34ab6e0 (2025-07-20_16-24-42Z) -->

_**User**_

let's start thinking about how we'll handle pulling changes from git. read @README.md @apps/api/README.md and @apps/docs/README.md then start thinking of a plan for how we can allow changes that happened in the git repo to get applied to the document as edits like any others

---

_**Agent (claude-opus-4-20250514)**_

I'll analyze how we can implement pulling changes from git and applying them to documents as edits. Let me first understand the current architecture better.

_**Agent (claude-opus-4-20250514)**_

Tool use: **Task** Search git integration code

Error:

```
The agent proposed a plan that was rejected by the user. The user chose to stay in plan mode rather than proceed with implementation.

Rejected plan:
## Current Git Integration Analysis

### 1. **Document Export to Git**
The system exports documents through the `GitSyncService` class (`/apps/api/src/services/git-sync.ts`):
- **Sync Endpoint**: `POST /api/v1/git/sync` triggers the export
- **Process**: Reads all documents from SQLite, fetches content from Automerge if available, writes to git repository
- **Batch Operation**: All changes are committed in a single commit per sync

### 2. **Git Repository Structure**
\```
git-repo/
├── .git/
├── documents/
│   ├── {id}-{filename}  # e.g., "149b9d49-fb5e-4f84-ade3-85742845d785-foo.md"
│   └── ...
└── .gitignore
\```
- **Location**: Development: `apps/api/git-repo/`, Production: `/data/git-repo/`
- **Directory**: All documents stored in `documents/` subdirectory

### 3. **Document ID to Filename Mapping**
- **Format**: `{document_id}-{sanitized_filename}`
- **Sanitization**: Special characters replaced with `-`, spaces with `_`, length limited to 200 chars
- **Benefits**: Prevents naming conflicts, maintains stable paths even if titles change

### 4. **Supported Git Operations**
Currently supports:
- **Initialize**: Auto-creates repository if not exists
- **Add**: New documents added to git
- **Update**: Modified documents updated based on content comparison
- **Delete**: Removed documents deleted from git
- **Commit**: Batch commits with timestamp or custom message
- **Push**: Optional push to remote repository (via GIT_REMOTE_URL env var)

### 5. **Reading from Git**
Currently, there is **NO implementation for reading from git**. The system is write-only:
- Documents flow only from database → git
- No import functionality from git → database
- No conflict resolution or merge capabilities

## Potential Enhancements

### 1. **Add Git Import Functionality**
- Create endpoint to read documents from git repository
- Parse filenames to extract document IDs
- Import content back to database/Automerge
- Handle conflicts between git and database versions

### 2. **Individual Commit Tracking**
- Currently batches all changes in one commit
- Could track individual document changes with meaningful commit messages
- Include user information in commits

### 3. **Git History Viewing**
- Add endpoint to view git commit history
- Show document change history from git perspective
- Integrate with UI to display version history

### 4. **Two-way Sync with Conflict Resolution**
- Implement pull from remote repository
- Develop conflict resolution strategy
- Support for branching and merging

### 5. **Real-time Sync Triggers**
- Currently manual sync only
- Could add automatic sync on document save
- WebSocket notifications for sync status

Would you like me to implement any of these enhancements, or do you have specific requirements for extending the git integration?
```

_**User**_

[Request interrupted by user for tool use]

_**User**_

help me understand in detail how the diffs from git will get applied. will they compleetely overwrite docs or just look like changes. what if people are editing the doc in realtime then what?

---

_**Agent (claude-opus-4-20250514)**_

Let me analyze the current Automerge implementation and think through how git changes should be applied to real-time collaborative documents.

_**Agent (claude-opus-4-20250514)**_

Tool use: **Task** Analyze Automerge document handling

Error:

```
The agent proposed a plan that was rejected by the user. The user chose to stay in plan mode rather than proceed with implementation.

Rejected plan:
## Analysis of Automerge Document System

### 1. How Document Edits are Applied

**Frontend (Client-side):**
- The `CollaborativeEditor` component uses the `automergeSyncPlugin` from `@automerge/automerge-codemirror`
- When users type in the CodeMirror editor, the plugin automatically converts text edits to Automerge operations
- The plugin is configured with `path: ['content']`, meaning changes are applied to the `content` field of the document
- Changes are applied through the `handle.change()` method which creates immutable updates

**Backend (Server-side):**
- Document updates happen through `DocumentService.updateDocumentContent()` which calls:
  \```typescript
  handle.change((doc) => {
    doc.content = content;
    doc.metadata.updatedAt = Date.now();
  });
  \```
- The `handle.change()` method creates a new immutable version of the document

### 2. How Automerge CRDT Handles Concurrent Edits

- Automerge uses operation-based CRDTs (Conflict-free Replicated Data Types)
- Each edit is converted to an operation with a unique identifier
- Operations are ordered by logical timestamps (Lamport timestamps)
- When concurrent edits occur:
  - Each client generates operations locally
  - Operations are synced via WebSocket to the server
  - The server broadcasts operations to all connected clients
  - Automerge automatically merges operations deterministically
  - All clients converge to the same document state

### 3. Relationship Between SQLite and Automerge

**Dual Storage System:**
- **SQLite `files` table**: Stores file metadata and content copy
  - `id`: UUID for the file
  - `filename`: File name
  - `content`: Text content (synced from Automerge)
  - `automerge_id`: Reference to Automerge document URL
  
- **SQLite `automerge_storage` table**: Stores Automerge binary data
  - `key`: Storage key (derived from document ID)
  - `data`: Binary CRDT data (operations, history)
  - Managed by `SQLiteStorageAdapter`

**Synchronization Flow:**
1. When content changes in Automerge, `DocumentService.updateFileFromDocument()` syncs to SQLite
2. REST API reads can use either Automerge content (preferred) or SQLite content (fallback)
3. Initial document creation copies SQLite content to Automerge

### 4. How Changes are Propagated Through WebSocket

**Two WebSocket Channels:**

1. **Automerge Sync (`/automerge-sync`):**
   - Uses `WebSocketServerAdapter` from `@automerge/automerge-repo-network-websocket`
   - Handles automatic CRDT synchronization
   - Binary protocol for efficient operation sync
   - Manages document discovery and sync state

2. **Socket.io (`/socket.io/`):**
   - Handles presence and awareness
   - Room-based architecture (`doc:${docId}`)
   - Events: `join-doc`, `leave-doc`, `presence`

**Propagation Flow:**
1. Client makes local change → Automerge generates operations
2. Operations sent via WebSocket to server
3. Server stores in `automerge_storage` and broadcasts to other clients
4. Remote clients receive and apply operations
5. All clients converge to same state

### 5. Existing Change/Patch Application Logic

**Key Methods:**

- **`handle.change(callback)`**: Primary method for modifying documents
  - Creates new immutable document version
  - Callback receives mutable proxy of document
  - Automerge tracks all modifications

- **Document Structure (`MarkdownDocument`):**
  \```typescript
  {
    content: string;
    comments?: { [id: string]: Comment };
    metadata?: {
      filename?: string;
      createdAt?: number;
      updatedAt?: number;
    };
  }
  \```

- **No Manual Patch Management**: 
  - Automerge handles all diff/patch logic internally
  - No explicit patch application code needed
  - Operations are automatically generated and applied

**Integration Points:**
- `automergeSyncPlugin` bridges CodeMirror edits to Automerge
- `WebSocketServerAdapter` handles network sync
- `SQLiteStorageAdapter` persists CRDT data
- `DocumentService` manages document lifecycle

This architecture provides real-time collaboration with automatic conflict resolution, requiring minimal manual intervention for change management.
```

_**User**_

[Request interrupted by user for tool use]

_**User**_

i don't think you understand what i'm asking. make a plan that covers what will happen if someone is live editing a doc and someone else edits that doc in the git repo and then we implement a feature in the app that allows the user to pull changes from the repo. explain what the live editor user will experience? will it just look like lines of diffs getting applied all at once?

---

_**Agent (claude-opus-4-20250514)**_

<think><details>The user is asking about a specific scenario: what happens when someone is actively editing a document in the real-time collaborative editor, and then we implement a feature that pulls changes from git (where someone else has edited the same document). They want to understand the user experience - will it look like diffs being applied all at once?

This is a complex question about how to merge external changes (from git) into a live Automerge document that may have active editors. I need to think through:

1. How git changes would be detected (comparing git content with current document content)
2. How those changes would be applied to the Automerge document
3. What the live editing user would see/experience
4. How Automerge would handle this scenario

Let me search for more specific information about how Automerge handles external content updates.</details></think>

_**Agent (claude-opus-4-20250514)**_

Tool use: **Read** `./apps/api/src/automerge/document-service.ts`

Result:

```
1→import { AutomergeUrl, DocHandle } from '@automerge/automerge-repo';
     2→import { getRepo } from './repo.js';
     3→import { getDB } from '../db/database.js';
     4→import type { MarkdownDocument } from './types.js';
     5→import { log } from '../utils/logger.js';
     6→
     7→export class DocumentService {
     8→  /**
     9→   * Get or create an Automerge document for a file
    10→   */
    11→  static async getOrCreateDocument(fileId: string): Promise<DocHandle<MarkdownDocument>> {
    12→    const db = getDB();
    13→    const repo = getRepo();
    14→    
    15→    // Check if file has an automerge_id
    16→    const file = db.prepare(`
    17→      SELECT id, filename, content, automerge_id 
    18→      FROM files 
    19→      WHERE id = ?
    20→    `).get(fileId) as { id: string; filename: string; content: string; automerge_id: string | null } | undefined;
    21→    
    22→    if (!file) {
    23→      throw new Error(`File not found: ${fileId}`);
    24→    }
    25→    
    26→    let handle: DocHandle<MarkdownDocument>;
    27→    
    28→    if (file.automerge_id) {
    29→      // File already has an Automerge document
    30→      log.info(`Loading existing Automerge document for file ${fileId}`);
    31→      handle = await repo.find<MarkdownDocument>(file.automerge_id as AutomergeUrl);
    32→    } else {
    33→      // Create new Automerge document
    34→      log.info(`Creating new Automerge document for file ${fileId}`);
    35→      handle = repo.create<MarkdownDocument>();
    36→      
    37→      // Initialize document with current content
    38→      handle.change((doc) => {
    39→        doc.content = file.content || '';
    40→        doc.comments = {};
    41→        doc.metadata = {
    42→          filename: file.filename,
    43→          createdAt: Date.now(),
    44→          updatedAt: Date.now()
    45→        };
    46→      });
    47→      
    48→      // Update file record with automerge_id
    49→      db.prepare(`
    50→        UPDATE files 
    51→        SET automerge_id = ?, updated_at = unixepoch() 
    52→        WHERE id = ?
    53→      `).run(handle.url, fileId);
    54→      
    55→      log.info(`Created Automerge document ${handle.url} for file ${fileId}`);
    56→    }
    57→    
    58→    return handle;
    59→  }
    60→  
    61→  /**
    62→   * Update file content from Automerge document
    63→   */
    64→  static async updateFileFromDocument(fileId: string, handle: DocHandle<MarkdownDocument>): Promise<void> {
    65→    const db = getDB();
    66→    const doc = handle.docSync();
    67→    
    68→    if (!doc) {
    69→      throw new Error('Document not loaded');
    70→    }
    71→    
    72→    // Update file content in database
    73→    db.prepare(`
    74→      UPDATE files 
    75→      SET content = ?, updated_at = unixepoch() 
    76→      WHERE id = ?
    77→    `).run(doc.content || '', fileId);
    78→    
    79→    log.debug(`Updated file ${fileId} from Automerge document`);
    80→  }
    81→  
    82→  /**
    83→   * Get document content
    84→   */
    85→  static async getDocumentContent(handle: DocHandle<MarkdownDocument>): Promise<string> {
    86→    await handle.doc(); // Ensure document is loaded
    87→    const doc = handle.docSync();
    88→    return doc?.content || '';
    89→  }
    90→  
    91→  /**
    92→   * Update document content
    93→   */
    94→  static updateDocumentContent(handle: DocHandle<MarkdownDocument>, content: string): void {
    95→    handle.change((doc) => {
    96→      doc.content = content;
    97→      if (doc.metadata) {
    98→        doc.metadata.updatedAt = Date.now();
    99→      }
   100→    });
   101→  }
   102→}
```

_**Agent (claude-opus-4-20250514)**_

<think><details>I see the `updateDocumentContent` method which does a simple replacement of the entire content. This is important - when we apply git changes, if we just replace the entire content, it would indeed appear as if the entire document was replaced at once to live editors.

Let me look at how the collaborative editor handles changes on the frontend to better understand the user experience.</details></think>

_**Agent (claude-opus-4-20250514)**_

Tool use: **Read** `./apps/docs/components/CollaborativeEditor.tsx`

Result:

```
1→'use client';
     2→
     3→import { useEffect, useState, useRef, useCallback } from 'react';
     4→import CodeMirror from '@uiw/react-codemirror';
     5→import { markdown } from '@codemirror/lang-markdown';
     6→import { EditorView, keymap } from '@codemirror/view';
     7→import { automergeSyncPlugin } from '@automerge/automerge-codemirror';
     8→import { useRepo } from '@automerge/automerge-repo-react-hooks';
     9→import type { MarkdownDocument } from '@/lib/automerge/types';
    10→import type { AutomergeUrl, DocHandle } from '@automerge/automerge-repo';
    11→import { commentsField, commentTheme, updateComments } from '@/lib/codemirror/comments-extension';
    12→import { Comment } from '@/lib/types/comment';
    13→
    14→export interface CollaborativeEditorProps {
    15→  documentUrl: string;
    16→  readOnly?: boolean;
    17→  placeholder?: string;
    18→  onConnectionChange?: (connected: boolean) => void;
    19→  onContentChange?: (content: string) => void;
    20→  onAddComment?: (selection: { from: number; to: number; text: string }) => void;
    21→  comments?: Comment[];
    22→  onCommentClick?: (position: number) => void;
    23→}
    24→
    25→export function CollaborativeEditor({ 
    26→  documentUrl, 
    27→  readOnly = false, 
    28→  placeholder,
    29→  onConnectionChange,
    30→  onContentChange,
    31→  onAddComment,
    32→  comments = [],
    33→  onCommentClick
    34→}: CollaborativeEditorProps) {
    35→  const repo = useRepo();
    36→  const [handle, setHandle] = useState<DocHandle<MarkdownDocument> | null>(null);
    37→  const [initialContent, setInitialContent] = useState<string>('');
    38→  const [isReady, setIsReady] = useState(false);
    39→  const editorViewRef = useRef<EditorView | null>(null);
    40→
    41→  // Get handle from repo
    42→  useEffect(() => {
    43→    if (!repo || !documentUrl) return;
    44→
    45→    const loadDocument = async () => {
    46→      try {
    47→        console.log('Finding document with URL:', documentUrl);
    48→        // repo.find() returns a Promise<DocHandle>
    49→        const docHandle = await repo.find<MarkdownDocument>(documentUrl as AutomergeUrl);
    50→        console.log('Got handle:', docHandle);
    51→        
    52→        setHandle(docHandle);
    53→
    54→        // Wait for the handle to be ready
    55→        const waitForReady = () => {
    56→          try {
    57→            // Check if handle has the isReady method and if it's ready
    58→            if (docHandle.isReady && !docHandle.isReady()) {
    59→              console.log('Handle not ready yet, waiting...');
    60→              setTimeout(waitForReady, 100);
    61→              return;
    62→            }
    63→
    64→            // Now we can safely call doc()
    65→            const currentDoc = docHandle.doc();
    66→            console.log('Got document:', currentDoc);
    67→            
    68→            if (currentDoc) {
    69→              // Initialize content if needed
    70→              if (currentDoc.content === undefined) {
    71→                docHandle.change((d) => {
    72→                  d.content = '';
    73→                });
    74→              }
    75→              
    76→              // Get the document again after potential change
    77→              const doc = docHandle.doc();
    78→              setInitialContent(doc?.content || '');
    79→              setIsReady(true);
    80→              onConnectionChange?.(true);
    81→            }
    82→          } catch (err) {
    83→            console.error('Error loading document:', err);
    84→            onConnectionChange?.(false);
    85→          }
    86→        };
    87→
    88→        waitForReady();
    89→      } catch (err) {
    90→        console.error('Error finding document:', err);
    91→        onConnectionChange?.(false);
    92→      }
    93→    };
    94→
    95→    loadDocument();
    96→
    97→  }, [repo, documentUrl, onConnectionChange]);
    98→
    99→  // Listen for changes on the handle
   100→  useEffect(() => {
   101→    if (!handle || !isReady) return;
   102→
   103→    const handleChange = () => {
   104→      try {
   105→        const currentDoc = handle.doc();
   106→        if (currentDoc) {
   107→          onContentChange?.(currentDoc.content || '');
   108→        }
   109→      } catch (err) {
   110→        console.error('Error handling change:', err);
   111→      }
   112→    };
   113→
   114→    handle.on('change', handleChange);
   115→
   116→    return () => {
   117→      handle.off('change', handleChange);
   118→    };
   119→  }, [handle, isReady, onContentChange]);
   120→
   121→  // Update comments in editor when they change
   122→  useEffect(() => {
   123→    if (editorViewRef.current && comments) {
   124→      updateComments(editorViewRef.current, comments);
   125→    }
   126→  }, [comments]);
   127→
   128→  // Handle comment keyboard shortcut
   129→  const handleAddComment = useCallback(() => {
   130→    if (!editorViewRef.current || !onAddComment) return false;
   131→    
   132→    const state = editorViewRef.current.state;
   133→    const selection = state.selection.main;
   134→    
   135→    if (selection.from === selection.to) {
   136→      // No selection
   137→      return false;
   138→    }
   139→    
   140→    const selectedText = state.doc.sliceString(selection.from, selection.to);
   141→    onAddComment({
   142→      from: selection.from,
   143→      to: selection.to,
   144→      text: selectedText
   145→    });
   146→    
   147→    return true;
   148→  }, [onAddComment]);
   149→
   150→  // Handle click on commented text
   151→  const handleCommentClick = useCallback((event: MouseEvent) => {
   152→    if (!editorViewRef.current || !onCommentClick) return;
   153→    
   154→    const pos = editorViewRef.current.posAtCoords({ x: event.clientX, y: event.clientY });
   155→    if (pos !== null) {
   156→      // Check if click is on a comment
   157→      const target = event.target as HTMLElement;
   158→      if (target.classList.contains('cm-comment-highlight')) {
   159→        onCommentClick(pos);
   160→      }
   161→    }
   162→  }, [onCommentClick]);
   163→
   164→  if (!handle || !isReady) {
   165→    return (
   166→      <div className="flex items-center justify-center h-full">
   167→        <div className="text-gray-500 dark:text-gray-400">Connecting to document...</div>
   168→      </div>
   169→    );
   170→  }
   171→
   172→  const syncPlugin = automergeSyncPlugin({
   173→    handle,
   174→    path: ['content'],
   175→  });
   176→
   177→  const extensions = [
   178→    markdown(),
   179→    syncPlugin,
   180→    commentsField,
   181→    commentTheme,
   182→    keymap.of([
   183→      {
   184→        key: 'Mod-k',
   185→        run: handleAddComment,
   186→      }
   187→    ]),
   188→    EditorView.domEventHandlers({
   189→      click: handleCommentClick,
   190→    }),
   191→    EditorView.theme({
   192→      '&': {
   193→        fontSize: '14px',
   194→        height: '100%',
   195→      },
   196→      '.cm-scroller': {
   197→        overflow: 'auto',
   198→        fontFamily: 'ui-monospace, SFMono-Regular, "SF Mono", Consolas, "Liberation Mono", Menlo, monospace',
   199→      },
   200→      '.cm-content': {
   201→        padding: '16px',
   202→        minHeight: '100%',
   203→      },
   204→      '.cm-focused .cm-cursor': {
   205→        borderLeftColor: '#3b82f6',
   206→      },
   207→      '.cm-line': {
   208→        padding: '0 2px 0 4px',
   209→      },
   210→    }),
   211→    EditorView.lineWrapping,
   212→  ];
   213→
   214→  if (readOnly) {
   215→    extensions.push(EditorView.editable.of(false));
   216→  }
   217→
   218→  // Provide initial value to CodeMirror
   219→  return (
   220→    <CodeMirror
   221→      value={initialContent}
   222→      extensions={extensions}
   223→      placeholder={placeholder}
   224→      theme={undefined} // Uses system theme
   225→      editable={!readOnly}
   226→      basicSetup={{
   227→        lineNumbers: true,
   228→        foldGutter: true,
   229→        dropCursor: !readOnly,
   230→        allowMultipleSelections: !readOnly,
   231→        indentOnInput: !readOnly,
   232→        bracketMatching: true,
   233→        closeBrackets: !readOnly,
   234→        autocompletion: !readOnly,
   235→        rectangularSelection: !readOnly,
   236→        highlightSelectionMatches: true,
   237→        searchKeymap: true,
   238→      }}
   239→      style={{ height: '100%' }}
   240→      onCreateEditor={(view) => {
   241→        editorViewRef.current = view;
   242→      }}
   243→    />
   244→  );
   245→}
```

_**Agent (claude-opus-4-20250514)**_

<think><details>Now I understand the architecture better. The `automergeSyncPlugin` connects CodeMirror to the Automerge document and keeps them in sync. When changes happen to the Automerge document, they are automatically reflected in the editor.

Let me search for information about how Automerge handles text operations and merging to better understand what would happen when external changes are applied.</details></think>

_**Agent (claude-opus-4-20250514)**_

Tool use: **Grep** path `./`

Result:

```
No matches found
```

_**Agent (claude-opus-4-20250514)**_

<think><details>Based on my analysis, I now understand the architecture well enough to explain what would happen. Let me create a comprehensive plan that explains the scenario and proposes how to implement git pull functionality while maintaining a good user experience for live editors.</details></think>

_**Agent (claude-opus-4-20250514)**_

Tool use: **exit_plan_mode**

Error:

```
The user doesn't want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). STOP what you are doing and wait for the user to tell you how to proceed.
```

_**User**_

[Request interrupted by user for tool use]

_**User**_

this is a good plan. write it in a planning document named git_pull_plan.md in the apps/api/plans folder. don't implement the plan yet.

---

_**Agent (claude-opus-4-20250514)**_

I'll create a detailed planning document for the git pull feature in the `apps/api/plans` folder.

_**Agent (claude-opus-4-20250514)**_

Tool use: **Write**

```md
# Git Pull Implementation Plan: Handling Live Editing Conflicts

## Overview

This document outlines the implementation plan for adding git pull functionality to the TnyOffice collaborative editor. The key challenge is integrating external git changes into documents that may be actively edited by users in real-time, without disrupting their editing experience.

## Current Architecture

### Existing Git Integration (One-way Export)
- Documents are exported to git as `{id}-{filename}.md` files
- Git sync is currently **write-only** (database → git)
- Located at `/api/v1/git/sync` endpoint
- Commits all changes in a single batch
- Optionally pushes to remote repository

### Real-time Collaboration System
- Automerge CRDT handles all real-time collaboration
- Document content stored as a simple string field: `doc.content`
- Changes propagated via WebSocket to all connected clients
- Automatic conflict resolution through CRDT operations
- CodeMirror editor with `automergeSyncPlugin` for seamless integration

## Problem Statement

### Scenario
1. **User A** is actively editing "design-spec.md" in the web app
2. **User B** edits the same document in git and pushes changes
3. **User A** (or admin) triggers "Pull from Git"
4. **Challenge**: How to merge git changes without disrupting User A's experience?

### Why Simple Replacement Won't Work

If we implement git pull using simple content replacement:
\```typescript
handle.change((doc) => {
  doc.content = gitContent; // BAD: Replaces entire document
});
\```

**User A would experience:**
- Entire document instantly replaced
- Cursor position jumps to beginning
- Text being typed is lost
- Feels like someone did "Select All" + Paste
- **Terrible user experience!**

## Proposed Solution: Diff-Based Merge

### Core Concept
Instead of replacing content wholesale, apply git changes as granular text operations that integrate naturally with Automerge's CRDT system. This makes external changes appear like collaborative edits from another user.

### Technical Approach

1. **Calculate Differences**
   - Use text diff algorithm (e.g., `diff-match-patch` library)
   - Compare current Automerge content with git content
   - Generate list of insertions, deletions, and unchanged regions

2. **Convert to Character-Level Operations**
   - Break down diffs into individual character operations
   - Maintain positional accuracy throughout document
   - Account for Automerge's internal text representation

3. **Apply Operations Sequentially**
   - Use Automerge's text manipulation methods
   - Apply changes in order to maintain consistency
   - Let CRDT handle any conflicts with concurrent edits

### Expected User Experience

**For User A (actively editing):**
- Changes appear gradually, like another user typing
- Cursor position preserved when possible
- Can continue typing without interruption
- Sees visual indicators of incoming changes
- No data loss - all changes merged

**Visual Feedback:**
- Temporary highlights on changed sections
- Toast notification: "Pulled X changes from git"
- Optional diff preview before applying
- Progress indicator during operation

## Implementation Plan

### Phase 1: Backend Infrastructure

#### 1.1 Git Pull Endpoint
\```typescript
POST /api/v1/git/pull
\```

**Request Body:**
\```json
{
  "remoteUrl": "https://github.com/user/repo.git", // optional
  "branch": "main", // optional, default: main
  "preview": false // if true, return diffs without applying
}
\```

**Response:**
\```json
{
  "success": true,
  "changes": [
    {
      "fileId": "abc-123",
      "filename": "design-spec.md",
      "status": "modified", // added|modified|deleted
      "additions": 45,
      "deletions": 12,
      "conflicts": 0
    }
  ],
  "appliedAt": "2025-01-20T10:30:00Z"
}
\```

#### 1.2 Git Diff Service
Create `apps/api/src/services/git-diff.ts`:

\```typescript
export class GitDiffService {
  // Calculate diff between git and Automerge content
  static calculateDiff(gitContent: string, automergeContent: string): DiffOperation[]
  
  // Apply diff operations to Automerge document
  static applyDiffToDocument(handle: DocHandle, operations: DiffOperation[]): void
  
  // Preview changes without applying
  static previewChanges(fileId: string): ChangePreview
}
\```

#### 1.3 Text Operation Types
\```typescript
interface DiffOperation {
  type: 'insert' | 'delete' | 'retain';
  position: number;
  text?: string; // for insert
  length?: number; // for delete/retain
}
\```

### Phase 2: Diff Application Logic

#### 2.1 Diff Algorithm Integration
- Add `diff-match-patch` dependency
- Configure for line-level or character-level diffs
- Optimize for minimal operations

#### 2.2 Automerge Text Operations
Implement careful position tracking:
\```typescript
// Apply operations in reverse order to maintain positions
operations.sort((a, b) => b.position - a.position);

handle.change((doc) => {
  for (const op of operations) {
    switch (op.type) {
      case 'insert':
        // Insert text at position
        doc.content = doc.content.slice(0, op.position) + 
                     op.text + 
                     doc.content.slice(op.position);
        break;
      case 'delete':
        // Delete characters
        doc.content = doc.content.slice(0, op.position) + 
                     doc.content.slice(op.position + op.length);
        break;
    }
  }
});
\```

#### 2.3 Conflict Detection
- Identify overlapping changes
- Mark potential conflict zones
- Let Automerge CRDT resolve naturally

### Phase 3: Frontend Integration

#### 3.1 UI Components
- "Pull from Git" button in document list
- Confirmation dialog with change preview
- Progress indicator during pull
- Success/error notifications

#### 3.2 Visual Indicators
- Highlight changed text temporarily
- Show diff markers in gutter
- Animation for smooth transitions

#### 3.3 User Controls
- Option to preview before applying
- Ability to reject specific changes
- Undo support for entire pull operation

### Phase 4: Edge Cases and Error Handling

#### 4.1 Document State Mismatches
- **New in git**: Create document in database
- **Deleted in git**: Mark as deleted, don't remove if active
- **Renamed in git**: Update metadata, preserve ID

#### 4.2 Large Documents
- Chunk operations for performance
- Show progress for long operations
- Implement operation batching

#### 4.3 Binary and Non-Markdown Files
- Detect file type from extension
- Skip or handle specially
- Warn user about skipped files

#### 4.4 Network and Authentication
- Handle git authentication failures
- Retry logic for network errors
- Timeout for long operations

### Phase 5: Testing Strategy

#### 5.1 Unit Tests
- Diff calculation accuracy
- Operation application correctness
- Position tracking with cursors
- Comment anchor preservation

#### 5.2 Integration Tests
- Full pull workflow
- Concurrent editing scenarios
- Large document handling
- Error recovery

#### 5.3 User Acceptance Tests
- Real-world editing scenarios
- Performance benchmarks
- UI responsiveness
- Data integrity verification

## Alternative Approaches Considered

### 1. Document Locking
- **Approach**: Lock documents during pull
- **Rejected**: Blocks collaboration, poor UX

### 2. Version Branching
- **Approach**: Create new version, let user merge
- **Rejected**: Splits document history, complex UI

### 3. Modal Merge Dialog
- **Approach**: Show merge UI like git
- **Rejected**: Interrupts workflow, not real-time

### 4. Queue System
- **Approach**: Queue changes, apply later
- **Rejected**: Delays, sync complexity

## Success Metrics

1. **Performance**
   - Pull operation < 5 seconds for typical documents
   - No UI freezing during operation
   - Smooth animation of changes

2. **Reliability**
   - Zero data loss
   - Correct merge in all test scenarios
   - Graceful error handling

3. **User Experience**
   - Users can continue editing during pull
   - Clear visual feedback
   - Intuitive conflict resolution

## Future Enhancements

1. **Selective Pull**
   - Choose specific files to pull
   - Filter by date or author

2. **Merge Strategies**
   - Different algorithms for different file types
   - User-configurable merge preferences

3. **Automation**
   - Scheduled pulls
   - Webhook integration for auto-pull

4. **Audit Trail**
   - Track who pulled when
   - Detailed change attribution

## Implementation Timeline

- **Week 1**: Backend infrastructure (Phase 1)
- **Week 2**: Diff logic and Automerge integration (Phase 2)
- **Week 3**: Frontend UI and visual feedback (Phase 3)
- **Week 4**: Edge cases and testing (Phase 4-5)

## Conclusion

This implementation ensures git changes integrate smoothly into the live collaborative editing experience without disrupting active users. By treating git changes as collaborative edits and leveraging Automerge's CRDT capabilities, we maintain the real-time, conflict-free editing experience users expect while adding powerful git integration features.
```

Result:

```
File created successfully at: /Users/jakelevirne/dev/specstoryai/tnyOffice/apps/api/plans/git_pull_plan.md
```

_**Agent (claude-opus-4-20250514)**_

I've created the git pull planning document at `/apps/api/plans/git_pull_plan.md`. The plan covers:

1. **The Problem**: How to merge git changes into actively edited documents without disrupting users
2. **The Solution**: Using diff-based operations that appear as collaborative edits rather than replacing entire content
3. **Implementation Details**: 
   - Backend infrastructure with new `/api/v1/git/pull` endpoint
   - Diff calculation and application logic
   - Frontend UI with preview and progress indicators
   - Edge case handling for new/deleted/renamed files
4. **User Experience**: Changes appear gradually like another user editing, preserving cursor position and allowing continued typing
5. **Technical Approach**: Converting git diffs to Automerge operations that integrate naturally with the CRDT system

The plan ensures that when someone pulls changes from git while others are actively editing, the experience feels smooth and natural - like collaborative edits rather than disruptive overwrites.

---

_**User**_

read this readme carefully https://github.com/onsetsoftware/automerge-repo-undo-redo . we need to make our own plan for undo in docs/plans/undo_redo_plan.md .. I don't want to use this github repo because it's not active. I want to learn from it and you read its code and you make our own plan for this.

---

_**Agent (claude-opus-4-20250514)**_

I'll analyze the automerge-repo-undo-redo repository and create our own undo/redo plan based on its approach.

_**Agent (claude-opus-4-20250514)**_

Tool use: **WebFetch**

Result:

```
Here's an analysis of the Automerge Repo Undo Redo implementation:

Key Concepts:
1. Document History Tracking
- Wraps Automerge's `DocHandle` to add undo/redo functionality
- Tracks specific changes made through the `AutomergeRepoUndoRedo` wrapper
- Preserves external changes from peers

2. Undo/Redo Mechanism
- Uses patches to store and revert changes
- Supports scoped changes (e.g., changes within a modal)
- Allows adding descriptions to changes
- Handles transactions that can include multiple changes

3. Main Classes/Functions
- `AutomergeRepoUndoRedo`: Primary class for tracking changes
- `change()`: Method to make tracked changes
- `transaction()`: Batch multiple changes together
- `undo()` and `redo()`: Revert or replay tracked changes
- `UndoRedoManager`: Manages undo/redo across multiple document handles

4. Collaborative Editing Considerations
- External changes from peers are not tracked
- Untracked changes can remain after undo operations
- Preserves document history across collaborative scenarios

5. Limitations/Issues
- Experimental implementation
- Potential unexpected results when altering document history
- Untracked changes can lead to inconsistent document states

Key Architecture:
- Tracks changes as patches
- Supports scoped and described changes
- Provides flexible undo/redo management across documents

Noteworthy Quote:
"This package is experimental and a work in progress. While it uses official automerge apis, it uses them to alter the history of your document, which may have unexpected results."
```

_**Agent (claude-opus-4-20250514)**_

Tool use: **WebFetch**

Result:

```
Based on the limited export statement provided, I cannot definitively analyze the implementation details you requested. The code snippet only shows export statements for:

- `defaultScope`
- `AutomergeRepoUndoRedo`
- `UndoRedoManager`
- A type export for `UndoRedoOptions`

To provide a comprehensive analysis of patches, undo/redo stack, change tracking, and transaction mechanisms, I would need to see the actual implementation files referenced in these exports. The current content is insufficient to draw meaningful conclusions about the internal workings of this undo/redo system.

Recommendation: Review the actual source files for `automerge-repo-undo-redo.ts` and `undo-redo-manager.ts` to gain insights into the implementation details.
```

_**Agent (claude-opus-4-20250514)**_

Tool use: **WebFetch**

Result:

```
Analysis of Automerge Undo/Redo Implementation:

1. Undo/Redo Stack Management:
- Uses a nested object `#stacks` with separate undo/redo arrays for different scopes
- Default scope is a Symbol called `defaultScope`
- Supports multiple independent change stacks via scope parameter

2. Patch Creation:
- Uses `patchCallback` to capture changes during document modifications
- Stores both redo and undo patches for each change
- Leverages `unpatchAll()` to generate reverse patches

3. Change Tracking:
- Tracks changes through a `#changeStack` during transactions
- Captures patch information including document heads before/after changes
- Stores change descriptions optionally

4. External vs Local Changes:
- Differentiates changes by comparing document heads
- Uses `equalArrays()` to check if current document state matches expected heads

5. Transaction Implementation:
- Supports nested change accumulation
- `startTransaction()` and `endTransaction()` methods
- Prevents multiple simultaneous transactions
- Applies accumulated changes in a single operation

6. Key Limitations/Edge Cases:
- Requires careful head tracking for complex merge scenarios
- Potential complexity with concurrent document modifications
- Relies on Automerge's patch and diff mechanisms
- Transactions can only be nested one level deep

The implementation provides a flexible undo/redo system with multi-scope support and robust change tracking.
```

_**Agent (claude-opus-4-20250514)**_

Now let me create a comprehensive undo/redo plan for our application based on this analysis.

_**Agent (claude-opus-4-20250514)**_

Tool use: **Write**

```md
# Undo/Redo Implementation Plan for TnyOffice Docs

## Overview

This document outlines the implementation plan for adding undo/redo functionality to the TnyOffice collaborative editor. The plan is inspired by the automerge-repo-undo-redo approach but tailored to our specific needs, with improvements for better integration with our collaborative editing environment.

## Core Concepts

### 1. Change Tracking Architecture

Unlike the reference implementation that wraps DocHandle, we'll integrate undo/redo directly into our collaborative editor component to:
- Track only user-initiated changes (not incoming collaborative changes)
- Maintain per-user undo/redo stacks
- Support document-specific history

### 2. Key Design Decisions

1. **User-Specific History**: Each user has their own undo/redo stack for their changes only
2. **Patch-Based Storage**: Use Automerge's patch system to store and reverse changes
3. **Scope Support**: Allow scoped undo/redo for specific features (e.g., comments, formatting)
4. **Transaction Support**: Batch related changes together (e.g., auto-formatting)
5. **Persistence**: Optionally persist undo history in localStorage

## Technical Architecture

### 1. Core Data Structures

\```typescript
interface UndoRedoEntry {
  id: string;                    // Unique identifier
  timestamp: number;             // When the change occurred
  description?: string;          // Optional human-readable description
  scope: string | symbol;        // Change scope (default or custom)
  patches: {
    redo: Patch[];              // Patches to apply the change
    undo: Patch[];              // Patches to reverse the change
  };
  heads: {
    before: Heads;              // Document state before change
    after: Heads;               // Document state after change
  };
  metadata?: {
    userId: string;             // Who made the change
    cursorPosition?: number;    // Cursor position before change
    selectionRange?: [number, number]; // Selection before change
  };
}

interface UndoRedoStack {
  undoStack: UndoRedoEntry[];
  redoStack: UndoRedoEntry[];
  maxStackSize: number;         // Limit memory usage
}

interface UndoRedoState {
  [documentId: string]: {
    [scope: string | symbol]: UndoRedoStack;
  };
}
\```

### 2. Implementation Components

#### 2.1 UndoRedoManager Class

\```typescript
class UndoRedoManager {
  private state: UndoRedoState = {};
  private activeTransaction: UndoRedoEntry | null = null;
  
  // Track a change
  trackChange(
    handle: DocHandle,
    changeCallback: (doc: any) => void,
    options?: {
      description?: string;
      scope?: string | symbol;
      metadata?: any;
    }
  ): void;
  
  // Undo last change
  undo(documentId: string, scope?: string | symbol): boolean;
  
  // Redo last undone change
  redo(documentId: string, scope?: string | symbol): boolean;
  
  // Transaction support
  startTransaction(description?: string): void;
  endTransaction(): void;
  
  // History management
  getHistory(documentId: string, scope?: string | symbol): UndoRedoEntry[];
  clearHistory(documentId: string, scope?: string | symbol): void;
}
\```

#### 2.2 React Hook Integration

\```typescript
function useUndoRedo(documentId: string, handle: DocHandle | null) {
  const [canUndo, setCanUndo] = useState(false);
  const [canRedo, setCanRedo] = useState(false);
  const manager = useRef(new UndoRedoManager());
  
  // Track changes made through the editor
  const trackChange = useCallback((
    changeCallback: (doc: any) => void,
    description?: string
  ) => {
    if (!handle) return;
    manager.current.trackChange(handle, changeCallback, { description });
    updateUndoRedoState();
  }, [handle]);
  
  // Keyboard shortcuts
  useEffect(() => {
    const handleKeydown = (e: KeyboardEvent) => {
      if (e.metaKey || e.ctrlKey) {
        if (e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          undo();
        } else if (e.key === 'z' && e.shiftKey || e.key === 'y') {
          e.preventDefault();
          redo();
        }
      }
    };
    
    window.addEventListener('keydown', handleKeydown);
    return () => window.removeEventListener('keydown', handleKeydown);
  }, [undo, redo]);
  
  return { undo, redo, canUndo, canRedo, trackChange };
}
\```

### 3. Integration Points

#### 3.1 CollaborativeEditor Integration

Modify the CollaborativeEditor to track user changes:

\```typescript
// In CollaborativeEditor component
const { undo, redo, canUndo, canRedo, trackChange } = useUndoRedo(documentId, handle);

// Track text changes
const handleTextChange = (newContent: string) => {
  trackChange((doc) => {
    doc.content = newContent;
  }, 'Edit text');
};

// Add undo/redo to toolbar
<Toolbar>
  <Button onClick={undo} disabled={!canUndo}>Undo</Button>
  <Button onClick={redo} disabled={!canRedo}>Redo</Button>
</Toolbar>
\```

#### 3.2 Comment System Integration

Track comment operations separately:

\```typescript
// When adding a comment
trackChange((doc) => {
  if (!doc.comments) doc.comments = {};
  doc.comments[commentId] = newComment;
}, 'Add comment', { scope: 'comments' });

// When deleting a comment
trackChange((doc) => {
  delete doc.comments[commentId];
}, 'Delete comment', { scope: 'comments' });
\```

### 4. Advanced Features

#### 4.1 Selective Undo

Allow users to undo specific types of changes:

\```typescript
interface UndoOptions {
  scope?: string | symbol;      // Undo only within scope
  filter?: (entry: UndoRedoEntry) => boolean; // Custom filter
  preserveRedoStack?: boolean;  // Don't clear redo on undo
}
\```

#### 4.2 Collaborative Awareness

Show other users when someone is undoing:

\```typescript
// Broadcast undo/redo operations
socket.emit('user-action', {
  type: 'undo',
  userId: currentUser.id,
  documentId,
  description: entry.description
});
\```

#### 4.3 Conflict Resolution

Handle cases where undo might conflict with other users' changes:

\```typescript
// Before applying undo patches
const currentHeads = handle.heads();
if (!equalHeads(entry.heads.after, currentHeads)) {
  // Document has changed since this operation
  // Attempt smart merge or show warning
  return handleUndoConflict(entry, currentHeads);
}
\```

### 5. User Experience Considerations

#### 5.1 Visual Feedback

- Flash or highlight the changed content briefly after undo/redo
- Show toast notifications for undo/redo operations
- Display undo history in a sidebar panel

#### 5.2 Cursor Restoration

\```typescript
// Store cursor position with each change
const cursorBefore = editor.getCursorPosition();
trackChange(changeCallback, description, {
  metadata: { cursorPosition: cursorBefore }
});

// Restore cursor after undo
const cursorPos = entry.metadata?.cursorPosition;
if (cursorPos !== undefined) {
  editor.setCursorPosition(cursorPos);
}
\```

#### 5.3 Undo Descriptions

Generate user-friendly descriptions:

\```typescript
function generateDescription(change: ChangeType): string {
  switch (change.type) {
    case 'text-edit':
      return `Edit text at line ${change.line}`;
    case 'comment-add':
      return `Add comment "${change.preview}"`;
    case 'format':
      return `Apply ${change.format} formatting`;
    default:
      return 'Edit document';
  }
}
\```

## Implementation Phases

### Phase 1: Core Undo/Redo (Week 1)

1. Implement UndoRedoManager class
2. Add patch tracking to document changes
3. Implement basic undo/redo operations
4. Add keyboard shortcuts

### Phase 2: React Integration (Week 1-2)

1. Create useUndoRedo hook
2. Integrate with CollaborativeEditor
3. Add UI controls (buttons, menu items)
4. Implement visual feedback

### Phase 3: Advanced Features (Week 2-3)

1. Add transaction support
2. Implement scoped undo/redo
3. Add comment system integration
4. Implement cursor restoration

### Phase 4: Collaborative Features (Week 3-4)

1. Add collaborative awareness
2. Implement conflict detection
3. Add undo history panel
4. Performance optimization

## Testing Strategy

### 1. Unit Tests

\```typescript
describe('UndoRedoManager', () => {
  test('tracks changes and creates patches');
  test('undoes changes in correct order');
  test('handles transaction grouping');
  test('respects scope boundaries');
  test('handles maximum stack size');
});
\```

### 2. Integration Tests

- Test with real Automerge documents
- Verify patch application correctness
- Test collaborative scenarios
- Verify cursor position restoration

### 3. E2E Tests

- User workflows with undo/redo
- Keyboard shortcut functionality
- Collaborative editing with undo
- Performance with large documents

## Performance Considerations

1. **Memory Management**
   - Limit undo stack size (default: 100 entries)
   - Compress patches for storage
   - Clear old entries periodically

2. **Patch Optimization**
   - Batch small changes together
   - Compress sequential text edits
   - Skip no-op changes

3. **Storage**
   - Optional localStorage persistence
   - Configurable retention period
   - Compression for storage

## Security Considerations

1. **Access Control**
   - Users can only undo their own changes
   - Respect document permissions
   - Audit trail for undo operations

2. **Data Integrity**
   - Validate patches before applying
   - Verify document heads match
   - Handle corrupt history gracefully

## Future Enhancements

1. **Visual History Timeline**
   - Graphical representation of changes
   - Jump to any point in history
   - Compare versions side-by-side

2. **Collaborative Undo**
   - Undo other users' changes (with permission)
   - Group undo for collaborative edits
   - Conflict resolution UI

3. **Smart Undo**
   - AI-powered change grouping
   - Semantic undo (undo concept, not just text)
   - Pattern recognition for repeated actions

## Conclusion

This implementation plan provides a robust undo/redo system that:
- Integrates seamlessly with Automerge's CRDT system
- Respects collaborative editing workflows
- Provides excellent user experience
- Scales to support advanced features

The phased approach allows for iterative development and testing, ensuring each component is solid before building on it.
```

Result:

```
File created successfully at: /Users/jakelevirne/dev/specstoryai/tnyOffice/apps/docs/plans/undo_redo_plan.md
```

_**Agent (claude-opus-4-20250514)**_

I've created a comprehensive undo/redo implementation plan at `/apps/docs/plans/undo_redo_plan.md`. The plan is based on analyzing the automerge-repo-undo-redo repository but tailored specifically for TnyOffice with several improvements:

## Key Highlights:

1. **User-Specific History**: Unlike the reference implementation, our plan tracks only individual user changes, not collaborative edits from others

2. **Better Integration**: Direct integration with our CollaborativeEditor component rather than wrapping DocHandle

3. **Advanced Features**:
   - Scoped undo/redo (e.g., separate for comments vs text)
   - Transaction support for grouping related changes
   - Cursor position restoration after undo/redo
   - Visual feedback and collaborative awareness

4. **Robust Architecture**:
   - Patch-based storage using Automerge's native capabilities
   - Conflict detection for collaborative scenarios
   - Memory management with configurable stack limits

5. **Enhanced UX**:
   - Keyboard shortcuts (Cmd/Ctrl+Z, Cmd/Ctrl+Shift+Z)
   - Visual indicators and toast notifications
   - Optional undo history panel

The plan includes detailed implementation phases, data structures, code examples, and testing strategies to ensure a smooth development process.

---

_**User**_

in the plan, capture the fact that we'll also need to do work so that undo/redo works nicely with comments so that when the user makes an undo or redo that modifies the text that a comment was associated with the right thing happens.

---

_**Agent (claude-opus-4-20250514)**_

I'll update the undo/redo plan to include detailed information about handling comments properly during undo/redo operations.

_**Agent (claude-opus-4-20250514)**_

Tool use: **Read** `./apps/docs/plans/undo_redo_plan.md`

Result:

```
1→# Undo/Redo Implementation Plan for TnyOffice Docs
     2→
     3→inspired by https://github.com/onsetsoftware/automerge-repo-undo-redo
     4→
     5→## Overview
     6→
     7→This document outlines the implementation plan for adding undo/redo functionality to the TnyOffice collaborative editor. The plan is inspired by the automerge-repo-undo-redo approach but tailored to our specific needs, with improvements for better integration with our collaborative editing environment.
     8→
     9→## Core Concepts
    10→
    11→### 1. Change Tracking Architecture
    12→
    13→Unlike the reference implementation that wraps DocHandle, we'll integrate undo/redo directly into our collaborative editor component to:
    14→- Track only user-initiated changes (not incoming collaborative changes)
    15→- Maintain per-user undo/redo stacks
    16→- Support document-specific history
    17→
    18→### 2. Key Design Decisions
    19→
    20→1. **User-Specific History**: Each user has their own undo/redo stack for their changes only
    21→2. **Patch-Based Storage**: Use Automerge's patch system to store and reverse changes
    22→3. **Scope Support**: Allow scoped undo/redo for specific features (e.g., comments, formatting)
    23→4. **Transaction Support**: Batch related changes together (e.g., auto-formatting)
    24→5. **Persistence**: Optionally persist undo history in localStorage
    25→
    26→## Technical Architecture
    27→
    28→### 1. Core Data Structures
    29→
    30→\```typescript
    31→interface UndoRedoEntry {
    32→  id: string;                    // Unique identifier
    33→  timestamp: number;             // When the change occurred
    34→  description?: string;          // Optional human-readable description
    35→  scope: string | symbol;        // Change scope (default or custom)
    36→  patches: {
    37→    redo: Patch[];              // Patches to apply the change
    38→    undo: Patch[];              // Patches to reverse the change
    39→  };
    40→  heads: {
    41→    before: Heads;              // Document state before change
    42→    after: Heads;               // Document state after change
    43→  };
    44→  metadata?: {
    45→    userId: string;             // Who made the change
    46→    cursorPosition?: number;    // Cursor position before change
    47→    selectionRange?: [number, number]; // Selection before change
    48→  };
    49→}
    50→
    51→interface UndoRedoStack {
    52→  undoStack: UndoRedoEntry[];
    53→  redoStack: UndoRedoEntry[];
    54→  maxStackSize: number;         // Limit memory usage
    55→}
    56→
    57→interface UndoRedoState {
    58→  [documentId: string]: {
    59→    [scope: string | symbol]: UndoRedoStack;
    60→  };
    61→}
    62→\```
    63→
    64→### 2. Implementation Components
    65→
    66→#### 2.1 UndoRedoManager Class
    67→
    68→\```typescript
    69→class UndoRedoManager {
    70→  private state: UndoRedoState = {};
    71→  private activeTransaction: UndoRedoEntry | null = null;
    72→  
    73→  // Track a change
    74→  trackChange(
    75→    handle: DocHandle,
    76→    changeCallback: (doc: any) => void,
    77→    options?: {
    78→      description?: string;
    79→      scope?: string | symbol;
    80→      metadata?: any;
    81→    }
    82→  ): void;
    83→  
    84→  // Undo last change
    85→  undo(documentId: string, scope?: string | symbol): boolean;
    86→  
    87→  // Redo last undone change
    88→  redo(documentId: string, scope?: string | symbol): boolean;
    89→  
    90→  // Transaction support
    91→  startTransaction(description?: string): void;
    92→  endTransaction(): void;
    93→  
    94→  // History management
    95→  getHistory(documentId: string, scope?: string | symbol): UndoRedoEntry[];
    96→  clearHistory(documentId: string, scope?: string | symbol): void;
    97→}
    98→\```
    99→
   100→#### 2.2 React Hook Integration
   101→
   102→\```typescript
   103→function useUndoRedo(documentId: string, handle: DocHandle | null) {
   104→  const [canUndo, setCanUndo] = useState(false);
   105→  const [canRedo, setCanRedo] = useState(false);
   106→  const manager = useRef(new UndoRedoManager());
   107→  
   108→  // Track changes made through the editor
   109→  const trackChange = useCallback((
   110→    changeCallback: (doc: any) => void,
   111→    description?: string
   112→  ) => {
   113→    if (!handle) return;
   114→    manager.current.trackChange(handle, changeCallback, { description });
   115→    updateUndoRedoState();
   116→  }, [handle]);
   117→  
   118→  // Keyboard shortcuts
   119→  useEffect(() => {
   120→    const handleKeydown = (e: KeyboardEvent) => {
   121→      if (e.metaKey || e.ctrlKey) {
   122→        if (e.key === 'z' && !e.shiftKey) {
   123→          e.preventDefault();
   124→          undo();
   125→        } else if (e.key === 'z' && e.shiftKey || e.key === 'y') {
   126→          e.preventDefault();
   127→          redo();
   128→        }
   129→      }
   130→    };
   131→    
   132→    window.addEventListener('keydown', handleKeydown);
   133→    return () => window.removeEventListener('keydown', handleKeydown);
   134→  }, [undo, redo]);
   135→  
   136→  return { undo, redo, canUndo, canRedo, trackChange };
   137→}
   138→\```
   139→
   140→### 3. Integration Points
   141→
   142→#### 3.1 CollaborativeEditor Integration
   143→
   144→Modify the CollaborativeEditor to track user changes:
   145→
   146→\```typescript
   147→// In CollaborativeEditor component
   148→const { undo, redo, canUndo, canRedo, trackChange } = useUndoRedo(documentId, handle);
   149→
   150→// Track text changes
   151→const handleTextChange = (newContent: string) => {
   152→  trackChange((doc) => {
   153→    doc.content = newContent;
   154→  }, 'Edit text');
   155→};
   156→
   157→// Add undo/redo to toolbar
   158→<Toolbar>
   159→  <Button onClick={undo} disabled={!canUndo}>Undo</Button>
   160→  <Button onClick={redo} disabled={!canRedo}>Redo</Button>
   161→</Toolbar>
   162→\```
   163→
   164→#### 3.2 Comment System Integration
   165→
   166→Track comment operations separately:
   167→
   168→\```typescript
   169→// When adding a comment
   170→trackChange((doc) => {
   171→  if (!doc.comments) doc.comments = {};
   172→  doc.comments[commentId] = newComment;
   173→}, 'Add comment', { scope: 'comments' });
   174→
   175→// When deleting a comment
   176→trackChange((doc) => {
   177→  delete doc.comments[commentId];
   178→}, 'Delete comment', { scope: 'comments' });
   179→\```
   180→
   181→### 4. Advanced Features
   182→
   183→#### 4.1 Selective Undo
   184→
   185→Allow users to undo specific types of changes:
   186→
   187→\```typescript
   188→interface UndoOptions {
   189→  scope?: string | symbol;      // Undo only within scope
   190→  filter?: (entry: UndoRedoEntry) => boolean; // Custom filter
   191→  preserveRedoStack?: boolean;  // Don't clear redo on undo
   192→}
   193→\```
   194→
   195→#### 4.2 Collaborative Awareness
   196→
   197→Show other users when someone is undoing:
   198→
   199→\```typescript
   200→// Broadcast undo/redo operations
   201→socket.emit('user-action', {
   202→  type: 'undo',
   203→  userId: currentUser.id,
   204→  documentId,
   205→  description: entry.description
   206→});
   207→\```
   208→
   209→#### 4.3 Conflict Resolution
   210→
   211→Handle cases where undo might conflict with other users' changes:
   212→
   213→\```typescript
   214→// Before applying undo patches
   215→const currentHeads = handle.heads();
   216→if (!equalHeads(entry.heads.after, currentHeads)) {
   217→  // Document has changed since this operation
   218→  // Attempt smart merge or show warning
   219→  return handleUndoConflict(entry, currentHeads);
   220→}
   221→\```
   222→
   223→### 5. User Experience Considerations
   224→
   225→#### 5.1 Visual Feedback
   226→
   227→- Flash or highlight the changed content briefly after undo/redo
   228→- Show toast notifications for undo/redo operations
   229→- Display undo history in a sidebar panel
   230→
   231→#### 5.2 Cursor Restoration
   232→
   233→\```typescript
   234→// Store cursor position with each change
   235→const cursorBefore = editor.getCursorPosition();
   236→trackChange(changeCallback, description, {
   237→  metadata: { cursorPosition: cursorBefore }
   238→});
   239→
   240→// Restore cursor after undo
   241→const cursorPos = entry.metadata?.cursorPosition;
   242→if (cursorPos !== undefined) {
   243→  editor.setCursorPosition(cursorPos);
   244→}
   245→\```
   246→
   247→#### 5.3 Undo Descriptions
   248→
   249→Generate user-friendly descriptions:
   250→
   251→\```typescript
   252→function generateDescription(change: ChangeType): string {
   253→  switch (change.type) {
   254→    case 'text-edit':
   255→      return `Edit text at line ${change.line}`;
   256→    case 'comment-add':
   257→      return `Add comment "${change.preview}"`;
   258→    case 'format':
   259→      return `Apply ${change.format} formatting`;
   260→    default:
   261→      return 'Edit document';
   262→  }
   263→}
   264→\```
   265→
   266→## Implementation Phases
   267→
   268→### Phase 1: Core Undo/Redo (Week 1)
   269→
   270→1. Implement UndoRedoManager class
   271→2. Add patch tracking to document changes
   272→3. Implement basic undo/redo operations
   273→4. Add keyboard shortcuts
   274→
   275→### Phase 2: React Integration (Week 1-2)
   276→
   277→1. Create useUndoRedo hook
   278→2. Integrate with CollaborativeEditor
   279→3. Add UI controls (buttons, menu items)
   280→4. Implement visual feedback
   281→
   282→### Phase 3: Advanced Features (Week 2-3)
   283→
   284→1. Add transaction support
   285→2. Implement scoped undo/redo
   286→3. Add comment system integration
   287→4. Implement cursor restoration
   288→
   289→### Phase 4: Collaborative Features (Week 3-4)
   290→
   291→1. Add collaborative awareness
   292→2. Implement conflict detection
   293→3. Add undo history panel
   294→4. Performance optimization
   295→
   296→## Testing Strategy
   297→
   298→### 1. Unit Tests
   299→
   300→\```typescript
   301→describe('UndoRedoManager', () => {
   302→  test('tracks changes and creates patches');
   303→  test('undoes changes in correct order');
   304→  test('handles transaction grouping');
   305→  test('respects scope boundaries');
   306→  test('handles maximum stack size');
   307→});
   308→\```
   309→
   310→### 2. Integration Tests
   311→
   312→- Test with real Automerge documents
   313→- Verify patch application correctness
   314→- Test collaborative scenarios
   315→- Verify cursor position restoration
   316→
   317→### 3. E2E Tests
   318→
   319→- User workflows with undo/redo
   320→- Keyboard shortcut functionality
   321→- Collaborative editing with undo
   322→- Performance with large documents
   323→
   324→## Performance Considerations
   325→
   326→1. **Memory Management**
   327→   - Limit undo stack size (default: 100 entries)
   328→   - Compress patches for storage
   329→   - Clear old entries periodically
   330→
   331→2. **Patch Optimization**
   332→   - Batch small changes together
   333→   - Compress sequential text edits
   334→   - Skip no-op changes
   335→
   336→3. **Storage**
   337→   - Optional localStorage persistence
   338→   - Configurable retention period
   339→   - Compression for storage
   340→
   341→## Security Considerations
   342→
   343→1. **Access Control**
   344→   - Users can only undo their own changes
   345→   - Respect document permissions
   346→   - Audit trail for undo operations
   347→
   348→2. **Data Integrity**
   349→   - Validate patches before applying
   350→   - Verify document heads match
   351→   - Handle corrupt history gracefully
   352→
   353→## Future Enhancements
   354→
   355→1. **Visual History Timeline**
   356→   - Graphical representation of changes
   357→   - Jump to any point in history
   358→   - Compare versions side-by-side
   359→
   360→2. **Collaborative Undo**
   361→   - Undo other users' changes (with permission)
   362→   - Group undo for collaborative edits
   363→   - Conflict resolution UI
   364→
   365→3. **Smart Undo**
   366→   - AI-powered change grouping
   367→   - Semantic undo (undo concept, not just text)
   368→   - Pattern recognition for repeated actions
   369→
   370→## Conclusion
   371→
   372→This implementation plan provides a robust undo/redo system that:
   373→- Integrates seamlessly with Automerge's CRDT system
   374→- Respects collaborative editing workflows
   375→- Provides excellent user experience
   376→- Scales to support advanced features
   377→
   378→The phased approach allows for iterative development and testing, ensuring each component is solid before building on it.
```

_**Agent (claude-opus-4-20250514)**_

Tool use: **Edit**

Result:

```
The file /Users/jakelevirne/dev/specstoryai/tnyOffice/apps/docs/plans/undo_redo_plan.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
   160→  <Button onClick={redo} disabled={!canRedo}>Redo</Button>
   161→</Toolbar>
   162→\```
   163→
   164→#### 3.2 Comment System Integration
   165→
   166→Track comment operations separately:
   167→
   168→\```typescript
   169→// When adding a comment
   170→trackChange((doc) => {
   171→  if (!doc.comments) doc.comments = {};
   172→  doc.comments[commentId] = newComment;
   173→}, 'Add comment', { scope: 'comments' });
   174→
   175→// When deleting a comment
   176→trackChange((doc) => {
   177→  delete doc.comments[commentId];
   178→}, 'Delete comment', { scope: 'comments' });
   179→\```
   180→
   181→#### 3.3 Comment-Text Synchronization During Undo/Redo
   182→
   183→**Critical Challenge**: When text changes are undone/redone, comments anchored to that text must adjust properly.
   184→
   185→**Current Implementation**: Comments use Automerge cursors (`startCursor` and `endCursor`) that automatically move with text edits. However, undo/redo operations need special handling:
   186→
   187→\```typescript
   188→interface CommentSyncStrategy {
   189→  // Before undo/redo, capture comment states
   190→  captureCommentState(doc: MarkdownDocument): CommentSnapshot[];
   191→  
   192→  // After undo/redo, reconcile comment positions
   193→  reconcileComments(
   194→    doc: MarkdownDocument, 
   195→    snapshots: CommentSnapshot[],
   196→    undoType: 'undo' | 'redo'
   197→  ): void;
   198→}
   199→
   200→interface CommentSnapshot {
   201→  commentId: string;
   202→  originalText: string;
   203→  startPos: number;
   204→  endPos: number;
   205→  cursorPositions: {
   206→    start: number | undefined;
   207→    end: number | undefined;
   208→  };
   209→}
   210→\```
   211→
   212→**Undo/Redo Behavior with Comments**:
   213→
   214→1. **Text Deletion Undo**: 
   215→   - When undoing a text deletion that removed commented text
   216→   - Comments should reappear at their original positions
   217→   - Cursors should expand back to encompass the restored text
   218→
   219→2. **Text Insertion Undo**:
   220→   - When undoing text insertion within a comment range
   221→   - Comment should shrink back to original boundaries
   222→   - Maintain comment integrity if text remains
   223→
   224→3. **Comment Orphaning**:
   225→   - If undo/redo causes commented text to completely disappear
   226→   - Mark comment as 'orphaned' but preserve it
   227→   - Show visual indicator that comment is orphaned
   228→
   229→4. **Cursor Position Validation**:
   230→   \```typescript
   231→   // After undo/redo, validate all comment positions
   232→   function validateCommentPositions(doc: MarkdownDocument) {
   233→     Object.entries(doc.comments || {}).forEach(([id, comment]) => {
   234→       if (comment.startCursor && comment.endCursor) {
   235→         const startPos = Automerge.getCursorPosition(doc, ['content'], comment.startCursor);
   236→         const endPos = Automerge.getCursorPosition(doc, ['content'], comment.endCursor);
   237→         
   238→         // Handle edge cases
   239→         if (startPos === endPos) {
   240→           comment.status = 'orphaned';
   241→         } else if (startPos > endPos) {
   242→           // Swap positions if they got reversed
   243→           [comment.anchorStart, comment.anchorEnd] = [endPos, startPos];
   244→         }
   245→       }
   246→     });
   247→   }
   248→   \```
   249→
   250→**Implementation Requirements**:
   251→
   252→1. **Wrap Undo/Redo Operations**:
   253→   \```typescript
   254→   function undoWithCommentSync(documentId: string) {
   255→     const handle = getDocumentHandle(documentId);
   256→     const doc = handle.docSync();
   257→     
   258→     // Capture comment state before undo
   259→     const commentSnapshots = captureCommentState(doc);
   260→     
   261→     // Perform undo
   262→     const success = manager.undo(documentId);
   263→     
   264→     if (success) {
   265→       // Reconcile comments after undo
   266→       handle.change((doc) => {
   267→         validateCommentPositions(doc);
   268→         reconcileOrphanedComments(doc, commentSnapshots);
   269→       });
   270→     }
   271→     
   272→     return success;
   273→   }
   274→   \```
   275→
   276→2. **Visual Feedback for Comment Changes**:
   277→   - Highlight comments that moved during undo/redo
   278→   - Show indicators for orphaned comments
   279→   - Animate comment position changes
   280→
   281→3. **Testing Scenarios**:
   282→   - Undo text deletion that contained comments
   283→   - Redo text insertion that splits comments
   284→   - Multiple undo/redo operations affecting same comment
   285→   - Collaborative edits interleaved with undo/redo
   286→
   287→### 4. Advanced Features
   288→
   289→#### 4.1 Selective Undo
```

_**Agent (claude-opus-4-20250514)**_

I've successfully updated the undo/redo plan to include a comprehensive section (3.3) on Comment-Text Synchronization During Undo/Redo. The additions cover:

1. **The Critical Challenge**: How to properly handle comments when the text they're anchored to changes during undo/redo operations

2. **Specific Scenarios**:
   - Text deletion undo (comments should reappear at original positions)
   - Text insertion undo (comments should shrink back)
   - Comment orphaning (when commented text disappears)
   - Cursor position validation after undo/redo

3. **Implementation Details**:
   - `CommentSyncStrategy` interface for capturing and reconciling comment states
   - `validateCommentPositions` function to handle edge cases like reversed positions
   - `undoWithCommentSync` wrapper function that ensures comments are properly adjusted after undo/redo

4. **Visual Feedback Requirements**:
   - Highlighting comments that moved
   - Indicators for orphaned comments
   - Animations for position changes

5. **Testing Scenarios**: Specific test cases for comment behavior during undo/redo operations

This ensures that when users undo or redo text changes, any comments associated with that text will behave correctly - either moving with the text, becoming orphaned if the text disappears, or maintaining their integrity through the operation.

