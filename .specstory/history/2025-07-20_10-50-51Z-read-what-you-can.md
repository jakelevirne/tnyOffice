<!-- Generated by SpecStory -->

# Automerge Real-Time Markdown Docs Sync (2025-07-20 10:50:51Z)

<!-- Claude Code Session 9fee6eec-18b6-40a8-9102-c8c289c4a0c6 (2025-07-20_10-50-51Z) -->

_**User**_

read what you can online about the automerge crdt project then help me understand where its using wasm in a scenario like a nextjs app as the frontend and a plain node api backend

---

_**Agent (claude-opus-4-20250514)**_

I'll help you understand how Automerge CRDT uses WebAssembly (WASM) in a Next.js frontend and Node.js backend scenario. Let me research this for you.

_**Agent (claude-opus-4-20250514)**_

Tool use: **WebSearch**

Result:

```
Web search results for query: "automerge CRDT WebAssembly WASM architecture Next.js Node.js 2025"

I'll search for information about Automerge CRDT with WebAssembly/WASM architecture in the context of Next.js and Node.js for 2025.

Links: [{"title":"Automerge Anywhere | Automerge CRDT","url":"https://automerge.org/blog/2024/08/23/wasm-packaging/"},{"title":"GitHub - automerge/automerge: A JSON-like data structure (a CRDT) that can be modified concurrently by different users, and merged again automatically.","url":"https://github.com/automerge/automerge"},{"title":"Automerge: A JSON-like Data Structure (a CRDT)","url":"https://morioh.com/a/1900eb8671e4/automerge-a-json-like-data-structure-a-crdt"},{"title":"Welcome to Automerge | Automerge CRDT","url":"https://automerge.org/docs/hello/"},{"title":"I was wrong. CRDTs are the future","url":"https://josephg.com/blog/crdts-are-the-future/"},{"title":"The JavaScript packages | Automerge CRDT","url":"https://automerge.org/docs/the_js_packages/"},{"title":"Code â€¢ Conflict-free Replicated Data Types","url":"https://crdt.tech/implementations"},{"title":"Architecture: Next.js Compiler | Next.js","url":"https://nextjs.org/docs/architecture/nextjs-compiler"},{"title":"Fouad Matin - How to Use WebAssembly (WASM) in Next.js","url":"https://www.linkedin.com/posts/fouadmatin_how-to-use-webassembly-wasm-in-nextjs-activity-7105600934579228673-jkSA"},{"title":"Will \"WebAssembly\" be the next generation of Java and Node.js? --Running \"Wasm Container\" with Kubernetes | NTT DATA Group","url":"https://www.nttdata.com/global/en/insights/focus/2024/will-webassembly-be-the-next-generation-of-java-and-nodejs"}]

Based on the search results, here's what I found about Automerge CRDT with WebAssembly/WASM architecture in the context of Next.js and Node.js:

## Automerge CRDT WebAssembly Architecture

Automerge's core CRDT is written in Rust, which allows binding to various languages including JavaScript, Swift, Kotlin, C, Go, and Python. In the browser, they compile the Rust code to WebAssembly.

### Recent WASM Packaging Improvements (2024)

In August 2024, Automerge returned to WASM packaging with determination and new ideas, resulting in new packaging options that make loading Automerge possible anywhere, including places where it was difficult or impossible before.

### Current Architecture

The repository contains the core Rust library which is compiled to WebAssembly and exposed in JavaScript. The JavaScript implementation uses @automerge/automerge-wasm (a wasm package considered an implementation detail) with the @automerge/automerge package offering a similar API to the original but forwarding logic to the WASM implementation.

### Integration with Next.js and Modern Bundlers

For Next.js and modern JavaScript environments, you can import the /slim variant of automerge and separately load the WebAssembly blob, then initialize it with Automerge.initializeWasm(wasm). Here's an example for Vite apps:

\```javascript
import { next as Automerge } from '@automerge/automerge/slim'
import wasm from "@automerge/automerge/automerge.wasm?url"
await Automerge.initializeWasm(wasm)
\```

### Next.js WebAssembly Support

Next.js Compiler supports WebAssembly through Rust's WASM support, which is essential for supporting all possible platforms. Next.js can use SWC's experimental plugin support written in WASM to customize transformation behavior, accepting npm module package names or absolute paths to .wasm binaries.

### Performance Improvements

Martin Kleppmann's columnar encoding can store text documents with only 1.5x-2x size overhead. Yjs (implementing Martin's ideas) can store a 100KB document in 160KB on disk or 3MB in memory.

### 2025 Outlook

While the search didn't yield specific 2025 roadmap information, the trend shows:
- WebAssembly is gradually shifting its target to server-side operation, similar to how Java and JavaScript spread from browser to server
- The focus includes iterating the API and adding new features with several major version bumps expected
- Network communication and storage are handled by a separate layer called automerge-repo

The architecture demonstrates a mature approach to CRDT implementation with strong WebAssembly integration suitable for both browser and Node.js environments in Next.js applications.
```

_**Agent (claude-opus-4-20250514)**_

Tool use: **WebFetch**

Result:

```
Here's a summary of Automerge's WebAssembly packaging improvements:

Key Highlights:
- Automerge's core is written in Rust and compiled to WebAssembly for cross-language compatibility
- New packaging options improve WebAssembly module loading across different environments

Initialization Approaches:
1. Standard Import (Vite/Modern Bundlers):
\```javascript
import { next as Automerge } from '@automerge/automerge/slim'
import wasm from "@automerge/automerge/automerge.wasm?url"
await Automerge.initializeWasm(wasm)
\```

2. Base64 Fallback (Challenging Environments):
\```javascript
import { automergeWasmBase64 } from "@automerge/automerge/automerge.wasm.base64.js"
await next.initializeBase64Wasm(automergeWasmBase64)
\```

Supported Environments:
- Vanilla JavaScript
- React Native
- Cloudflare Workers
- Val.town
- Various bundlers and browsers

Key Recommendation: Libraries should "only import the `@automerge/automerge/slim` package" to maintain flexibility for users.

The goal is to make Automerge "possible anywhere, including quite a few places where it was difficult or impossible before."
```

_**Agent (claude-opus-4-20250514)**_

Tool use: **WebFetch**

Error:

```
Request failed with status code 404
```

_**Agent (claude-opus-4-20250514)**_

Tool use: **WebSearch**

Result:

```
Web search results for query: ""@automerge/automerge" "@automerge/automerge-wasm" difference WASM integration Node.js browser"

I'll search for information about the differences between @automerge/automerge and @automerge/automerge-wasm packages, particularly regarding WASM integration in Node.js and browser environments.

Links: [{"title":"@automerge/automerge - npm","url":"https://www.npmjs.com/package/@automerge/automerge"},{"title":"@automerge/automerge-wasm - npm","url":"https://www.npmjs.com/package/@automerge/automerge-wasm"},{"title":"Automerge Anywhere | Automerge CRDT","url":"https://automerge.org/blog/2024/08/23/wasm-packaging/"},{"title":"GitHub - orionz/automerge at wasm-node","url":"https://github.com/orionz/automerge/tree/wasm-node"},{"title":"@automerge/automerge-repo - npm","url":"https://www.npmjs.com/package/@automerge/automerge-repo"},{"title":"GitHub - automerge/automerge: A JSON-like data structure (a CRDT) that can be modified concurrently by different users, and merged again automatically.","url":"https://github.com/automerge/automerge"},{"title":"automerge-wasm - npm","url":"https://www.npmjs.com/package/automerge-wasm"},{"title":"automerge-backend-wasm - npm","url":"https://www.npmjs.com/package/automerge-backend-wasm"},{"title":"automerge - npm","url":"https://www.npmjs.com/package/automerge"},{"title":"Automerge","url":"https://automerge.org/docs/reference/the_js_packages/"}]

Based on the search results, I can explain the key differences between `@automerge/automerge` and `@automerge/automerge-wasm`:

## Main Differences

### 1. **Package Relationship**
@automerge/automerge is a wrapper around a core library which is written in rust, compiled to WebAssembly and distributed as a separate package called @automerge/automerge-wasm. The @automerge/automerge package offers a very similar API to the original automerge package but implemented by forwarding logic to @automerge/automerge-wasm.

### 2. **API Level**
- **@automerge/automerge-wasm**: This package is a low level interface to the automerge rust CRDT. The api is intended to be as "close to the metal" as possible with only a few ease of use accommodations
- **@automerge/automerge**: Provides a higher-level, more user-friendly API that wraps the low-level WASM implementation

### 3. **Purpose and Usage**
- **@automerge/automerge-wasm**: This library is used as the underpinnings for the Automerge JS wrapper and can be used as is or as a basis for another higher level expression of a CRDT. This wasm package is something we currently consider to be an implementation detail and should not be depended on by third parties
- **@automerge/automerge**: The main package that developers should use in their applications

### 4. **Browser Integration**
Browsers don't currently support WebAssembly modules taking part in ESM module imports, so you must use a bundler to import @automerge/automerge in the browser. For webpack, you need to enable the `asyncWebAssembly` experiment.

### 5. **Node.js vs Browser**
- **Node.js**: If you're writing a node application, you can skip straight to Make some data - it works transparently
- **Browser**: Requires bundler configuration to handle the WASM module properly

### 6. **Memory Management**
Allocated memory in rust will be freed automatically on platforms that support FinalizationRegistry. This is currently supported in all major browsers and nodejs. On unsupported platforms you can free memory explicitly

### 7. **Recent Packaging Improvements**
What we have done is introduce a few new ways to load Automerge by including the option for manual initialization of the WASM object and a base64 encoded string version as well. This allows for better compatibility across different environments.

## Recommendation
Unless you have specific low-level requirements, you should use `@automerge/automerge` rather than `@automerge/automerge-wasm` directly. The higher-level package provides a more convenient API while still benefiting from the performance of the Rust/WASM implementation.
```

_**Agent (claude-opus-4-20250514)**_

Based on my research, here's how Automerge CRDT uses WebAssembly in a Next.js + Node.js scenario:

## Architecture Overview

**Core Implementation**: Automerge's core CRDT logic is written in Rust and compiled to WebAssembly. This provides:
- High performance for conflict resolution algorithms
- Cross-platform compatibility (browser, Node.js, mobile)
- Memory safety from Rust

## How WASM Works in Different Environments

### Next.js Frontend
```javascript
// For Next.js client-side
import { next as Automerge } from '@automerge/automerge/slim'
import wasm from "@automerge/automerge/automerge.wasm?url"

// Initialize WASM before using Automerge
await Automerge.initializeWasm(wasm)
```

Next.js requires bundler configuration (webpack's `asyncWebAssembly` experiment) since browsers don't natively support WASM in ESM imports.

### Node.js Backend
```javascript
// Node.js works transparently - WASM loads automatically
import { next as Automerge } from '@automerge/automerge'

// Use directly - no manual WASM initialization needed
const doc = Automerge.init()
```

## Package Structure

- **@automerge/automerge**: High-level JavaScript API wrapper
- **@automerge/automerge-wasm**: Low-level WASM bindings (implementation detail)
- **@automerge/automerge-repo**: Network/storage layer for syncing

## Why WASM?

1. **Performance**: Complex CRDT algorithms run at near-native speed
2. **Consistency**: Same Rust code runs everywhere
3. **Memory efficiency**: Columnar encoding stores documents with only 1.5-2x overhead
4. **Type safety**: Rust's guarantees prevent memory issues

The WASM approach allows Automerge to handle real-time collaboration efficiently across both your Next.js frontend and Node.js backend while maintaining consistency through the same underlying Rust implementation.

